```html
<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <!-- Titolo della Pagina Dinamico -->
        <title>Abbracciare la Trasformazione Digitale</title>

        <!-- Meta Descrizione per SEO -->
        <meta name="description" content="&lt;p&gt;In questo episodio, Darren parla della diminuzione della congestione dell&amp;#39;ingestione utilizzando la memoria persistente Optane DC di Intel e dell&amp;#39;esperimento da lui condotto con risultati sorprendenti. Potrebbe cambiare il modo in cui pensiamo alla programmazione in futuro.&lt;/p&gt;
">

        <!-- Parole Chiave per SEO -->
        <meta name="keywords" content="podcast, ai, edge computing, cybersecurity, trasformazione digitale">

        <!-- Meta Autore -->
        <meta name="author" content="Darren W Pulsipher">

        <!-- Meta Tag Open Graph per i Social Media -->
        <meta property="og:title" content="Abbracciare la Trasformazione Digitale">
        <meta property="og:description" content="&lt;p&gt;In questo episodio, Darren parla della diminuzione della congestione dell&amp;#39;ingestione utilizzando la memoria persistente Optane DC di Intel e dell&amp;#39;esperimento da lui condotto con risultati sorprendenti. Potrebbe cambiare il modo in cui pensiamo alla programmazione in futuro.&lt;/p&gt;
">
        <meta property="og:image" content="thumbnail.png">

        <meta property="og:url" content="https://embracingdigital.org">
        <meta property="og:type" content="website">

        <!-- Meta Tag Twitter Card -->
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:title" content="Abbracciare la Trasformazione Digitale">
        <meta name="twitter:description" content="&lt;p&gt;In questo episodio, Darren parla della diminuzione della congestione dell&amp;#39;ingestione utilizzando la memoria persistente Optane DC di Intel e dell&amp;#39;esperimento da lui condotto con risultati sorprendenti. Potrebbe cambiare il modo in cui pensiamo alla programmazione in futuro.&lt;/p&gt;
">
        <meta name="twitter:image" content="thumbnail.png">

    <title>Abbracciare la Trasformazione Digitale</title>

    <link rel="stylesheet" href="../../../css/styles.css">
    <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-P4XHVE79DL"></script>
    <script> window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }
    gtag('js', new Date());
    gtag('config', 'G-P4XHVE79DL'); </script>
</head>
<body>

<!-- üåç Barra di Navigazione -->
<header>
    <div class="logo-container">
        <img src="../../../images/logo.png" alt="Abbracciare la Trasformazione Digitale" class="site-icon">
    </div>
    <nav>
        <ul>
            <li><a href="../../../it/home/index.html">Home</a></li>
            <li><a href="../../../it/about.html">Informazioni</a></li>
            <li><a href="../../../it/episodes/index.html">Interviste</a></li>
            <li><a href="../../../it/briefs/index.html">Notizie</a></li>
            <li><a href="../../../it/community.html">Comunit√†</a></li>
            <li><a href="../../../it/guests/index.html">Ospiti</a></li>
            <li><a href="https://6704f0-2.myshopify.com/">Negozio</a></li>
            <li><a href="../../../it/search.html">Cerca</a></li>
            <li class="dropdown">
                <a href="#">Lingue</a>
                <ul class="dropdown-menu">
                    <li><a href="../../../ar/home/index.html">ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</a></li> <!-- Arabo -->
                    <li><a href="../../../de/home/index.html">Deutsch</a></li> <!-- Tedesco -->
                    <li><a href="../../../en/home/index.html">English</a></li> <!-- Inglese -->
                    <li><a href="../../../fr/home/index.html">Fran√ßais</a></li> <!-- Francese -->
                    <li><a href="../../../it/home/index.html">Italiano</a></li> <!-- Italiano -->
                    <li><a href="../../../pt/home/index.html">Portugu√™s</a></li> <!-- Portoghese -->
                    <li><a href="../../../ja/home/index.html">Êó•Êú¨Ë™û</a></li> <!-- Giapponese -->
                </ul>
            </li>
        </ul>
    </nav>
</header>
```
<section id="one-episode">
    <h1 id="episode-title">#16 Ridurre la congestione di ingestione con Intel Optane DCPMM</h1>
    <div class="episode-container">
        <!-- YouTube Video Section -->
        <div class="video-container">
            <iframe width="auto" height="auto" src="https://www.youtube.com/embed/url?autoplay=1" title="Episode Playback"></iframe>
        </div>

        <!-- Podcast Audio Section -->
        <div class="podcast-container">
            <iframe width="100%" height="180" frameborder="no" scrolling="no" seamless="" src="https://share.transistor.fm/e/7ca179aa"></iframe>
        </div>
        <div class="show-summary">
            <p><p>In questo episodio, Darren parla della diminuzione della congestione dell&#39;ingestione utilizzando la memoria persistente Optane DC di Intel e dell&#39;esperimento da lui condotto con risultati sorprendenti. Potrebbe cambiare il modo in cui pensiamo alla programmazione in futuro.</p>
</p>

            <!-- Tags Section -->
            <div class="tags">
                
                    <a href="../../../it/search.html?query=artificialintelligence"><span>artificialintelligence</span></a>
                
                    <a href="../../../it/search.html?query=machinelearning"><span>machinelearning</span></a>
                
                    <a href="../../../it/search.html?query=edgecomputing"><span>edgecomputing</span></a>
                
                    <a href="../../../it/search.html?query=datamanagement"><span>datamanagement</span></a>
                
                    <a href="../../../it/search.html?query=multicloud"><span>multicloud</span></a>
                
                    <a href="../../../it/search.html?query=zerotrust"><span>zerotrust</span></a>
                
                    <a href="../../../it/search.html?query=process"><span>process</span></a>
                
                    <a href="../../../it/search.html?query=technology"><span>technology</span></a>
                
            </div>

            <!-- Guests Section -->
            <div class="guests">
                
                <a href="../../../it/guests/darren-w-pulsipher/index.html" target="_blank">Darren W Pulsipher</a>
            </div>
        </div>

        <!-- Show Notes Section -->
        <div class="show-notes">
            <h2>Dettagli sullo stack di servizi</h2>
<p>Un cliente nel settore automobilistico stava avendo difficolt√† nel riuscire ad ottenere in modo efficace informazioni dalle proprie auto e trasferirle nel loro data center in modo da poter effettuare apprendimento automatico e analisi dati. In questa area √® stata condotta una ricerca, ma solo per un numero limitato di auto, non per i cento milioni di auto del cliente. Quando ho esaminato l&#39;intera struttura del loro servizio e come tutto arrivava al data center, √® emerso che l&#39;ingestione dei dati era il problema principale: come posso assimilare cos√¨ tanti dati e come posso farlo velocemente?</p>
<h2>Panoramica dell&#39;architettura Kafka a livello superiore.</h2>
<p>Il cliente voleva utilizzare Kafka per l&#39;ingestione dei dati. Kafka √® un intermediario che pu√≤ scalare bene e la sua caratteristica principale √® quella di poter gestire diversi produttori, consumatori differenti e una grande quantit√† di dati. Utilizzare diversi intermediari Kafka per posizionare e inviare dati nei luoghi pi√π appropriati offre una grande flessibilit√†.</p>
<p>Kafka, tuttavia, √® stato principalmente progettato per dimensioni dei messaggi di circa uno a 10 kilobytes e i dati del cliente erano di circa 240 kilobytes per automobile. Ci sono soluzioni alternative, ma volevo portare l&#39;intero messaggio di 240 kilobytes nel bus di Kafka in modo da poterlo spostare come necessario.</p>
<h2>Pratiche ottimali per le performance</h2>
<p>Ho analizzato le migliori pratiche di performance di coloro che lavorano con Kafka per vedere se potevo adattarle alle esigenze del mio cliente. Aumentare la dimensione del buffer per ospitare l&#39;intero messaggio √® una soluzione di fine-tuning, insieme alla gestione delle dimensioni dei batch per prestazioni ottimali. Un&#39;altra pratica di successo √® distribuire i log. La flessibilit√† di Kafka mi consentirebbe di inserire i dati in diversi argomenti. Posso suddividere gli argomenti in diverse partizioni che posso distribuire su pi√π unit√†. La domanda √®, dunque, su quante unit√† sto distribuendo i log di Kafka? Inoltre, desidero le unit√† pi√π veloci possibili.</p>
<p>Un esempio che ho esaminato √® LinkedIn. I numeri pubblicati da loro di un anno fa indicano che possono gestire 13 milioni di messaggi al secondo, o 2,7 gigabyte al secondo. Dicono di avere circa 1.100 broker Kafka e pi√π di 60 su un cluster, quindi si tratta di una configurazione abbastanza grande.</p>
<h2>Spazio automobilistico</h2>
<p>Se guardo i numeri grezzi del cliente (1,6 milioni di messaggi al secondo e 800 gigabyte al secondo) e li confronto con LinkedIn, che probabilmente non √® ottimizzato per 240 kilobyte, ottengo 44.000 broker. Se lo ottimizzassi, potrei probabilmente ridurli a 4.400 broker, che sono ancora 240 cluster. √à un enorme quantit√† di macchine, quindi ho dovuto trovare un modo per rendere le cose pi√π veloci. Con ulteriori ottimizzazioni, potrei probabilmente ridurlo a 400-500 broker, ma volevo vedere cos&#39;altro potevo fare.</p>
<h2>Intel Optane DC Persistent Memory:</h2>
<p>Memoria persistente Intel Optane DC</p>
<p>Ho esaminato la nostra memoria persistente Optane. Si adatta al formato DDR4, quindi si posiziona direttamente sul bus DDR4. Arriva fino a moduli da 512 gigabyte, quindi in un server a due socket posso avere sei terabyte di memoria persistente. Volevo trovare un modo per sfruttare questa tecnologia altamente affidabile con ottime funzionalit√† come la crittografia hardware integrata per aiutarmi a risolvere questo problema.</p>
<h2>Supporto per la Variazione di Applicazioni</h2>
<p>Ci sono due modalit√† di funzionamento con questa Memoria Optane: modalit√† app diretta e modalit√† memoria. La modalit√† memoria √® semplice. Utilizza la memoria persistente come una normale RAM perch√© √® pi√π economica rispetto alla normale DDR4. Non √® esattamente la stessa cosa della DDR4, ma √® abbastanza simile al punto che nella maggior parte delle applicazioni non si nota alcuna differenza. Nella modalit√† app diretta, √® possibile scrivere direttamente dalla tua applicazione nella memoria persistente. In questo modo, non √® necessario convertire e decodificare le strutture dati e trasmetterle come flusso; posso semplicemente inserirle nella memoria persistente. Posso anche montare la modalit√† app diretta come un sistema di file, in modo che sia sul bus di memoria, molto pi√π veloce rispetto al bus di I/O. Ora, cosa posso fare con questa memoria?</p>
<h2>Utilizzando il kernel Linux</h2>
<p>Ci sono due strumenti principali disponibili utilizzando il kernel Linux: ndctl e ipmctl. Ndctl √® un controller per dispositivi di memoria non volatile, mentre c&#39;√® anche IPM, il controller di memoria persistente Intel, che mi permette di manipolare e controllare questa memoria persistente. Posso configurarla in modalit√† memoria o modalit√† app diretta. Ho dovuto imparare un po&#39; su questi strumenti e come funzionano.</p>
<h2>Approccio di ingestione</h2>
<p>Il mio primo pensiero √® stato che se avessi dato a Kafka molta pi√π memoria con dimensioni di buffer grandi, avrebbe dovuto funzionare molto pi√π velocemente. I cambiamenti del codice nella configurazione sarebbero stati superflui o minimi. Un&#39;altra opzione era cambiare Kafka in modo da scrivere sulla memoria persistente anzich√© sul file system, aggirando l&#39;hard disk. L&#39;ultima cosa che ho esaminato √® stata la creazione di un file system persistente utilizzando la memoria persistente e quindi mettendo i log di Kafka su questo nuovo file system.</p>
<p>La opzione pi√π semplice tra le tre era la prima: pi√π memoria. Ho eseguito tutti i miei compiti con pi√π memoria e non c&#39;√® stata alcuna variazione delle prestazioni. I motivi sono che alla fine i miei buffer si sono riempiti e ho dovuto trasferire i dati su un&#39;unit√† esterna. Alla fine tutto doveva passare per i log di Kafka, che erano il mio collo di bottiglia.</p>
<p>La seconda opzione prevede la riscrittura del codice e l&#39;attesa delle approvazioni, quindi sono passato alla terza opzione. I risultati di questo esperimento, in cui ho indirizzato i log a questo nuovo file system ultra veloce, sono stati affascinanti. Diamo uno sguardo al processo e ai risultati.</p>
<h2>Test dei vincoli</h2>
<p>Per eliminare gli ostacoli alla valutazione delle prestazioni, ho escluso il network dall&#39;equazione facendo girare il mio test sulla stessa macchina su cui era presente il mio broker. Inoltre, ho eseguito solo i produttori, poi solo i consumatori, e infine una combinazione dei due, in modo da poter valutare le differenze. Il mio obiettivo non era quello di valutare il miglioramento totale della produzione, ma di analizzare singolarmente il broker per capire se questo drive avrebbe davvero fatto la differenza.</p>
<h2>Primo Approccio 50/50</h2>
<p>La prima cosa che ho fatto √® stata prendere la met√† della mia memoria persistente in modalit√† diretta dell&#39;app e trasformarla in un sistema di file. Ho lasciato l&#39;altra met√† come memoria. Ho utilizzato i comandi ndctl e ipmctl e creato spazi di nomi. Ho montato questi sistemi di file e ho eseguito il mio test.</p>
<h2>Cambiare la dimensione del messaggio</h2>
<p>Ho eseguito i test su diverse dimensioni di messaggio. Mi aspettavo alcune ottimizzazioni, soprattutto per 1 kilobyte. Ho notato che ottenivo prestazioni sempre migliori fino a circa 10 produttori. Oltre i 10 produttori, ho iniziato a saturare il bus e ho ottenuto qualche variabilit√†. Questo mi indica che stavo memorizzando le cose nella cache. Ora potrei confrontare questi numeri con quelli ottenuti precedentemente con un solo disco SATA per i registri Kafka. Ho provato anche i nostri dischi Optane NVMe per i registri.</p>
<h2>Confronto tecnologico</h2>
<p>Diamo un&#39;occhiata alle differenze. Per 240 kilobyte, con un normale disco SATA, √® piuttosto piatto. Ho ottenuto un certo miglioramento, e poi √® diminuito man mano che il numero di produttori aumentava. Con il disco Optane NVMe, ho ottenuto un bel picco, quasi due volte pi√π veloce di un disco SATA, il che √® quello che mi aspettavo dato che √® un bus NVMe invece di un bus SATA. Il Pmem √® quasi cinque volte pi√π veloce di un disco SATA e due volte e mezzo pi√π veloce del disco Optane NVMe. Questo perch√© sto usando un bus di memoria invece del bus SATA o NVMe.</p>
<h2>Ottimizzazione aggiuntiva (100% diretto all&#39;app)</h2>
<p>Questo stava funzionando velocemente e stavo rapidamente riempiendo questo disco temporaneo da 750 GB. Siccome avevo bisogno di far durare il test un po&#39; pi√π a lungo, sono tornato indietro e ho riconfigurato la mia macchina per eseguire una modalit√† di applicazione diretta al 100 percento in modo da poter ora prendere l&#39;intero terabyte e mezzo (1.5 terabyte).</p>
<h2>Ottimizzato PMEM e App Direct al 100%.</h2>
<p>Dopo aver fatto ci√≤ e aver eseguito gli stessi test, ho ottenuto un risultato sorprendente. Ho potuto aggiungere pi√π produttori e la mia capacit√† di trasmissione √® aumentata di quasi altre due o tre volte. Ora √® tra 12 e 15 volte pi√π veloce di un disco SATA con 25-30 produttori e una dimensione dei messaggi di 240 kilobyte. Questo √® incredibile e ridurrebbe notevolmente la necessit√† dei miei clienti di utilizzare cos√¨ tanti broker, righe e righe di macchine. Ho eseguito il test diverse volte perch√© non credevo ai risultati che stavo ottenendo. Ho chiamato uno dei nostri architetti che ha progettato questa tecnologia e ho appreso che una delle ragioni per l&#39;aumento della velocit√† √® che, quando usavo parte della memoria persistente come memoria, i dati dovevano passare attraverso due o tre salti non necessari con l&#39;app direct mode. Ci√≤ crea meno contesa sul bus di memoria e la capacit√† di trasmissione √® aumentata in modo significativo.</p>
<h2>Chiamata all&#39;azione</h2>
<p>Il risultato finale √® che sono stato in grado di utilizzare Kafka con Optane DC Persistent Memory come un sistema di file ultra-veloce per ottenere notevoli miglioramenti nella velocit√† di throughput sia per i produttori che per i consumatori. Un singolo broker pu√≤ gestire fino a 15 volte pi√π messaggi e throughput rispetto a prima, diminuendo il numero di server necessari per gestire architetture di sistemi grandi e complesse. √à ora di valutare la tua attuale architettura e vedere se questo potrebbe beneficiare la tua organizzazione.</p>

        </div>
    </div>
</section>
<footer id="footer">
    <div class="footer-content">
        <p>Copyright &copy; 2025 Paidar Productions LLC</p>
        <p>Diritti riservati</p>
    </div>
</footer>
